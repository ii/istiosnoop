#+title: Loading Db
#+PROPERTY: header-args:sql-mode+ :product postgres

* Introduction
This is a template org file for working with queries in our apisnoop and infrasnoop databases.
These are two databases runinng on the same postgres engine, connected in two sessions in this org file.

* APISnoop
:PROPERTIES:
:header-args:sql-mode+: :session apisnoop :database apisnoop :dbuser apisnoop
:END:
** IMPORTANT
All sql blocks in here are running in our infrasnoop session.
However, when starting for the first time, you want to make sure you are putting in the user/db/server prompts correctly.
They are:
- user :: apisnoop
- database :: apisnoop
- server :: localhost

#+begin_comment
we should be able to do this in header args, but could not get them working.
#+end_comment

** Test it works
#+begin_src sql-mode
select * from describe_relations();
#+end_src

#+RESULTS:
#+begin_SRC example
   schema    |             name             |                                                description
-------------+------------------------------+------------------------------------------------------------------------------------------------------------
 testing     | audit_event                  | every event from an e2e test run, or multiple test runs.
 testing     | endpoint_hit_by_new_test     |
 testing     | projected_change_in_coverage |
 testing     | untested_stable_endpoint     |
 public      | audit_event                  | every event from an e2e test run, or multiple test runs.
 public      | audit_event_test             | every test in the audit_log of a release
 public      | endpoint_coverage            | Coverage info for every endpoint in a release, taken from audit events for that release
 public      | open_api                     | endpoint details from openAPI spec
 conformance | coverage_per_release         | How many endopoints from a release are tested today?
 conformance | eligible_endpoint            | all current stable endpoints for which conformant tests could be written, following conformance guidelines
 conformance | ineligible_endpoint          | endpoints ineligible for conformance testing
 conformance | new_endpoint                 | eligible endpoints sorted by release and whether they are tested
 conformance | progress                     | per release, the # of new, eligible endpoints and coverage ratios
 conformance | test                         | info for each conformance test, from latest conformance.yaml
(14 rows)

#+end_SRC

#+begin_src sql-mode
select * from load_live_open_api();
#+end_src

#+RESULTS:
#+begin_SRC example
   load_live_open_api
-------------------------
 live open api is loaded
(1 row)

#+end_SRC

** Looking at Istio Endpoints
Our database is connected to a cluster running istio, and configured for auditing.  All audit events are logged by apisnoop and inserted
into the testing.audit_event table, with endpoints connected based on the openapi spec generated by this cluster.

So we can see all the istio endpoints in the audit_event table with

#+begin_src sql-mode
select distinct endpoint,release
  from testing.audit_event
 where endpoint ilike '%istio%';
#+end_src

#+RESULTS:
#+begin_SRC example
                           endpoint                           | release
--------------------------------------------------------------+---------
 listNetworkingIstioIoV1alpha3EnvoyFilterForAllNamespaces     | live
 listNetworkingIstioIoV1alpha3GatewayForAllNamespaces         | live
 listNetworkingIstioIoV1alpha3ServiceEntryForAllNamespaces    | live
 listNetworkingIstioIoV1beta1ServiceEntryForAllNamespaces     | live
 listNetworkingIstioIoV1beta1VirtualServiceForAllNamespaces   | live
 listSecurityIstioIoV1beta1PeerAuthenticationForAllNamespaces | live
 listSecurityIstioIoV1RequestAuthenticationForAllNamespaces   | live
(7 rows)

#+end_SRC

** Getting additional detai from incluster spec
We have a function ~load_live_open_api~, that adds a 'live' release to our open_api table, populated with the incluster spec.
I already ran it to populate the table, so now we can join our testing events to this spec to get additional details.

for example:

#+begin_src sql-mode
with istio_eps as (
  select endpoint,useragent,data
    from testing.audit_event
   where endpoint ilike '%istio%'
)
select endpoint, description, path
  from istio_eps
       join open_api using(endpoint)
 group by endpoint,description,path
 limit 5;
#+end_src

#+RESULTS:
#+begin_SRC example
                          endpoint                          |             description             |                       path
------------------------------------------------------------+-------------------------------------+---------------------------------------------------
 listNetworkingIstioIoV1alpha3EnvoyFilterForAllNamespaces   | list objects of kind EnvoyFilter    | /apis/networking.istio.io/v1alpha3/envoyfilters
 listNetworkingIstioIoV1alpha3GatewayForAllNamespaces       | list objects of kind Gateway        | /apis/networking.istio.io/v1alpha3/gateways
 listNetworkingIstioIoV1alpha3ServiceEntryForAllNamespaces  | list objects of kind ServiceEntry   | /apis/networking.istio.io/v1alpha3/serviceentries
 listNetworkingIstioIoV1beta1ServiceEntryForAllNamespaces   | list objects of kind ServiceEntry   | /apis/networking.istio.io/v1beta1/serviceentries
 listNetworkingIstioIoV1beta1VirtualServiceForAllNamespaces | list objects of kind VirtualService | /apis/networking.istio.io/v1beta1/virtualservices
(5 rows)

#+end_SRC

* Footnotes
** function: load_live_open_api
#+begin_src sql-mode :session apisnoop
begin;
create or replace function load_live_open_api (
  )
returns text AS $$
from string import Template
import json
import time
import datetime
from urllib.request import Request, urlopen, urlretrieve
import urllib
import yaml
import ssl
from pathlib import Path

ssl._create_default_https_context = ssl._create_unverified_context
token = Path('/token.txt').read_text()
req = Request('https://kubernetes/openapi/v2')
req.add_header('Authorization','Bearer ' + token)

open_api = json.loads(urlopen(req).read().decode('utf-8'))
release =  'live'
release_date = time.mktime(datetime.datetime.now().timetuple())
open_api_url = 'incluster'

sql = Template("""
   WITH open AS (
     SELECT '${open_api}'::jsonb as api_data
     )
       INSERT INTO open_api(
         release,
         release_date,
         endpoint,
         level,
         category,
         path,
         k8s_group,
         k8s_version,
         k8s_kind,
         k8s_action,
         deprecated,
         description,
         spec
       )
   SELECT
     '${release}' as release,
     to_timestamp(${release_date}) as release_date,
     (d.value ->> 'operationId'::text) as endpoint,
     CASE
       WHEN paths.key ~~ '%alpha%' THEN 'alpha'
       WHEN paths.key ~~ '%beta%' THEN 'beta'
       -- these endpoints are beta, but are not marked as such, yet, in the swagger.json
       WHEN (d.value ->> 'operationId'::text) = any('{"getServiceAccountIssuerOpenIDConfiguration", "getServiceAccountIssuerOpenIDKeyset"}') THEN 'beta'
       ELSE 'stable'
     END AS level,
     split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
     paths.key AS path,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
     (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
     CASE
       WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
       ELSE false
     END AS deprecated,
                 (d.value ->> 'description'::text) AS description,
                 '${open_api_url}' as spec
     FROM
         open
          , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
          , jsonb_each(paths.value) d(key, value)
          , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
    ORDER BY paths.key;
              """).substitute(release = release,
                              release_date = str(release_date),
                              open_api = json.dumps(open_api).replace("'","''"),
                              open_api_url = open_api_url)
try:
  plpy.execute((sql))
  return "{} open api is loaded".format(release)
except Exception as e:
  return "an error occurred: " + str(e) + "\nrelease: " + release
$$ LANGUAGE plpython3u ;
reset role;

comment on function load_live_open_api is 'loads given release to open_api table from incluster api spec.';

select 'load_live_open_api function defined and commented' as "build log";
commit;
#+end_src

#+RESULTS:
#+begin_SRC example
BEGIN
apisnoop=*# apisnoop(*# apisnoop-*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# apisnoop$*# CREATE FUNCTION
apisnoop=*# RESET
apisnoop=*# apisnoop=*# COMMENT
apisnoop=*# apisnoop=*#                      build log
---------------------------------------------------
 load_live_open_api function defined and commented
(1 row)

apisnoop=*# COMMIT
#+end_SRC

#+begin_src sql-mode
select * from load_live_open_api();
#+end_src

#+RESULTS:
#+begin_SRC example
   load_live_open_api
-------------------------
 live open api is loaded
(1 row)

#+end_SRC
